#include <conio.h>  // Подключаем библиотеку conio.h, которая содержит функцию _getch() для чтения символа с клавиатуры
#include <iostream> // Включаем библиотеку для ввода/вывода данных
#include <vector>   // Включаем библиотеку для работы с векторами
#include <string>   // Включаем библиотеку для работы со строками
using namespace std; // Используем пространство имен std, чтобы не писать std::

// Объявляем функцию для выполнения операции
double calculate(double num1, double num2, char operation);

// Объявляем функцию для получения приоритета операции
int precedence(char operation);

// Объявляем функцию для вычисления выражения
double evaluation(string expression);

int main() {
    setlocale(LC_ALL, "");
    string expression; // Объявляем переменную для хранения выражения
    char choice; // Объявляем переменную choice для хранения выбора пользователя
    do
    {
        cout << "Введите выражение: "; // Выводим на экран приглашение к вводу
        getline(cin, expression); // Считываем строку, введенную пользователем
        cout << "Результат = " << evaluation(expression) << endl; // Выводим результат вычисления выражения
        cout << "Если вы хотите выйти, введите 'q'!\n";   // Выводим сообщение, что для выхода нужно ввести 'q'
        choice = _getch(); // Считываем символ, нажатый пользователем, используя функцию _getch()
    } while (choice != 'q');  // Если введенный символ не равен 'q', то цикл продолжается
    
    return 0;
}

// Функция для выполнения операции
double calculate(double num1, double num2, char operation) {
    switch (operation) { // Выбираем операцию в зависимости от переданного символа
    case '+': // Если операция - сложение
        return num1 + num2; // Возвращаем результат сложения
    case '-': // Если операция - вычитание
        return num1 - num2; // Возвращаем результат вычитания
    case '*': // Если операция - умножение
        return num1 * num2; // Возвращаем результат умножения
    case '/': // Если операция - деление
        if (num2 != 0) // Проверяем, что делитель не равен нулю
            return num1 / num2; // Возвращаем результат деления
        else { // Если делитель равен нулю
            cerr << "Ошибка! Деление на ноль не допускается." << endl; // Выводим сообщение об ошибке
            return 0; // Возвращаем 0
        }
    }
    return 0; // Если операция не распознана, возвращаем 0
}

// Функция для получения приоритета операции
int precedence(char operation) {
    switch (operation) { // Выбираем операцию в зависимости от переданного символа
    case '+': // Если операция - сложение или вычитание
    case '-': // Если операция - сложение или вычитание
        return 1; // Возвращаем приоритет 1
    case '*': // Если операция - умножение или деление
    case '/': // Если операция - умножение или деление
        return 2; // Возвращаем приоритет 2
    }
    return 0; // Если операция не распознана, возвращаем 0
}

// Функция для вычисления выражения
double evaluation(string expression) {
    vector<double> numbers; // Объявляем вектор для хранения чисел
    vector<char> operations; // Объявляем вектор для хранения операций

    for (char c : expression) { // Проходим по каждому символу в выражении
        if (isdigit(c)) { // Если символ - цифра
            numbers.push_back(c - '0'); // Преобразуем символ в число и добавляем его в вектор чисел
        }
        else if (c == '(') { // Если символ - открывающая скобка
            operations.push_back(c); // Добавляем его в вектор операций
        }
        else if (c == ')') { // Если символ - закрывающая скобка
            while (!operations.empty() && operations.back() != '(') { // Пока в стеке не пуст и последняя операция не открывающая скобка
                double num2 = numbers.back(); // Берем последнее число из вектора чисел
                numbers.pop_back(); // Удаляем последнее число из вектора чисел
                double num1 = numbers.back(); // Берем предыдущее число из вектора чисел
                numbers.pop_back(); // Удаляем предыдущее число из вектора чисел
                char operation = operations.back(); // Берем последнюю операцию из вектора операций
                operations.pop_back(); // Удаляем последнюю операцию из вектора операций

                numbers.push_back(calculate(num1, num2, operation)); // Выполняем операцию и добавляем результат в вектор чисел
            }

            if (!operations.empty()) // Если в стеке операций есть элементы
                operations.pop_back(); // Удаляем последнюю операцию из стека операций
        }
        else { // Если символ - операция
            while (!operations.empty() && precedence(c) <= precedence(operations.back())) { // Пока в стеке не пуст и приоритет новой операции меньше или равен приоритету последней операции в стеке
                double num2 = numbers.back(); // Берем последнее число из вектора чисел
                numbers.pop_back(); // Удаляем последнее число из вектора чисел
                double num1 = numbers.back(); // Берем предыдущее число из вектора чисел
                numbers.pop_back(); // Удаляем предыдущее число из вектора чисел
                char operation = operations.back(); // Берем последнюю операцию из вектора операций
                operations.pop_back(); // Удаляем последнюю операцию из вектора операций

                numbers.push_back(calculate(num1, num2, operation)); // Выполняем операцию и добавляем результат в вектор чисел
            }

            operations.push_back(c); // Добавляем новую операцию в вектор операций
        }
    }

    while (!operations.empty()) { // Пока в стеке операций есть элементы
        double num2 = numbers.back(); // Берем последнее число из вектора чисел
        numbers.pop_back(); // Удаляем последнее число из вектора чисел
        double num1 = numbers.back(); // Берем предыдущее число из вектора чисел
        numbers.pop_back(); // Удаляем предыдущее число из вектора чисел
        char operation = operations.back(); // Берем последнюю операцию из вектора операций
        operations.pop_back(); // Удаляем последнюю операцию из вектора операций

        numbers.push_back(calculate(num1, num2, operation)); // Выполняем операцию и добавляем результат в вектор чисел
    }

    return numbers.back(); // Возвращаем последнее число из вектора чисел, которое является результатом вычисления выражения
}